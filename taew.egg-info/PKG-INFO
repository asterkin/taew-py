Metadata-Version: 2.4
Name: taew
Version: 2.1.0
Summary: Python foundation library that supports rapid development of evolvable MVPs without premature technology lock-in.
Author-email: Asher Sterkin <asher.sterkin@gmail.com>
License: MIT
Requires-Python: >=3.13
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: docstring-parser>=0.17.0
Dynamic: license-file

# taew-py

**Ports & Adapters foundation library for Python applications**

`taew-py` is a Python foundation library that supports rapid development of evolvable MVPs without premature technology lock-in. By implementing the Ports & Adapters (Hexagonal Architecture) pattern, it enables you to build applications where core business logic remains independent of external technologies and frameworks.

The name **taew** comes from the Elvish word for "socket" - a [programmable port](https://www.elfdict.com/w/taew) that adapts to different needs.

## The Problem

When building MVPs, developers face a dilemma:
- **Move fast** by coupling directly to specific technologies (databases, frameworks, cloud providers)
- **Move carefully** by building extensive abstractions upfront

The first approach leads to **technology lock-in** that becomes increasingly painful to change. The second creates **upfront complexity** that slows initial development.

## The Solution

`taew-py` provides a third path: **write business logic against protocol-based ports or ABCs, then plug in adapters as needed**. This enables:

- **Rapid prototyping** with simple adapters (in-memory, standard library)
- **Gradual evolution** by swapping adapters without changing core logic
- **Technology freedom** through clean separation of concerns
- **Type safety** via Python protocols and strict type checking

Start with Python standard library adapters (this repository), then add technology-specific adapters (AWS, databases, web frameworks) from separate repositories as your needs evolve.

## Architecture Rationale

The `taew-py` library organizes code into three fundamental layers:

**Domain Data Structures**
- Pure data classes and types
- No behavior or logic - just data representation
- Foundation for all operations across the system

**Ports**
- Interfaces describing operations on domain structures
- Defined as Protocols (preferred) or ABCs when inheritance is needed
- No implementation - only contracts
- A **port** is a group of related interfaces bound to the same technology concern (e.g., read/write operations, send/receive operations)

**Adapters**
- Concrete implementations of ports built on specific technologies
- Bridge between abstract ports and real-world tools (databases, APIs, file systems, etc.)
- Each adapter targets a specific technology stack

### Core Components

**Domain Layer** (`taew/domain/`)
- Pure domain data structures
- Configuration types for port and application setup

**Ports Layer** (`taew/ports/`)
- Protocol-based or ABC-based interface definitions
- Examples: binding interfaces, browsing code trees, building parsers, serializing objects

**Adapters Layer** (`taew/adapters/`)
- Python standard library-based implementations
- CLI adapters for command-line interface support
- Launch-time adapters for dependency injection and instantiation

**Utils** (`taew/utils/`)
- Minimal common utilities - kept as small as possible

### Configuration-Driven Wiring

Adapters are selected at runtime through Python data structures (`AppConfiguration` and `PortsMapping`):

```python
from taew.domain.configuration import AppConfiguration, PortConfiguration

config = AppConfiguration(
    ports={
        ports.for_serializing_objects: PortConfiguration(
            adapter_module="taew.adapters.python.pprint.for_serializing_objects"
        ),
        ports.for_browsing_code_tree: PortConfiguration(
            adapter_module="taew.adapters.python.inspect.for_browsing_code_tree"
        ),
    }
)
```

Configuration is encoded in Python data structures for maximum flexibility. Helper `Configure` classes are provided for all `taew` adapters to enable automatic generation when needed.

This design enables:
- **Zero code changes** when swapping implementations
- **Testing flexibility** using lightweight adapters (e.g., in-memory vs. database)
- **Gradual migration** from simple to sophisticated technologies

## Key Design Principles

### Application Layer Separation

`taew-py` promotes clean architecture through strict import boundaries:

1. **Application Domain** - No `taew` imports
   - Pure domain data structures and business logic
   - Completely independent of the framework

2. **Application Ports** - No `taew` imports (only application domain)
   - Interface definitions using Protocols or ABCs
   - May reference domain data structures

3. **Application Workflows** - No specific adapters or `taew` imports
   - Orchestrates domain logic through port interfaces
   - Only depends on application domain and ports

4. **Application Adapters** - `taew` imports allowed
   - Customizations of generic `taew` adapters
   - Implements application port interfaces

5. **Application Configuration** - `taew` imports allowed
   - Wires adapters to ports
   - Python data structures for maximum flexibility
   - Helper `Configure` classes provided for all `taew` adapters

### Framework Philosophy

- **Not Opinionated** - `taew` does not enforce any specific interpretation of Ports & Adapters
- **Good Practices Made Easy** - Aims to make sound architectural patterns straightforward to apply
- **Standard Library First** - Prefers Python stdlib interfaces (collections, protocols) whenever possible; in many ways, `taew-py` extends them for Ports & Adapters development
- **Type Safety** - Python 3.14+ with full utilization of strong type annotations
- **AI-Friendly from Day One** - Once domain structures and ports are defined (can be brainstormed with AI), developing specific technology adapters becomes a straightforward process that's easy and safe to delegate completely to AI agents
- **CLI First MVP** - close to zero code conversion of application workflows to CLI commands

## Sample Application
TODO: reference to bluezone sample application

### Evolvable Applications

Start with simple adapters, evolve as needed:

1. **Prototype** - Use in-memory adapters for quick validation
2. **MVP** - Switch to SQLite or local file storage
3. **Scale** - Migrate to cloud databases without changing business logic
4. **Optimize** - Add caching layers or specialized storage

Each transition requires only adapter changes, not core logic rewrites.

## Technology-Specific Adapters

While this repository contains Python standard library adapters, technology-specific adapters are developed in separate repositories:

- Cloud adapters (Buckets, Functions, etc.) - e.g. `taew-adapters-aws`
- 3rd Party Database adapters (PostgreSQL, MySQL, MongoDB) - e.g.`taew-adapters-pg`
- Web framework adapters (FastAPI, Flask, Django) - `taew-adapters-flask`

This separation enables:
- **Minimal dependencies** - Only include what you need
- **Independent evolution** - Adapters update on their own schedules
- **Technology-specific testing** - Each adapter suite tests against real services

## User Guide

**TBD** - Comprehensive user guide will be added covering installation, basic usage, and common patterns.

## Project Structure

**TBD** - Project structure will be formally documented in an Architecture Decision Record (ADR).

## Contributing

This project follows strict type checking and formatting standards:

1. **Python 3.14+** - Full utilization of modern type annotations
2. All code must pass `mypy` and `pyright` with zero errors
3. Use `ruff` for formatting (run `make ruff-format`)
4. Maintain 100% test coverage for new features
5. Write tests against protocols, not implementations

### Development Setup

This project uses `uv` for dependency management and `make` for task automation.

```bash
# Clone the repository
git clone https://github.com/asterkin/taew-py.git
cd taew-py

# Create and activate virtual environment
uv venv
source .venv/bin/activate  # or .venv\Scripts\activate on Windows

# Install dependencies
uv sync

# Run the full verification suite
make all
```

### Common Commands

- `make all` - Run complete pipeline (static analysis + tests with coverage)
- `make static` - Run ruff, mypy, and pyright
- `make coverage` - Run tests with coverage analysis
- `make test-unit` - Run unit tests only
- `make ruff-format` - Format code

### Testing Strategy

Tests are written against port protocols, not concrete implementations:

```python
from taew.ports.for_stringizing_objects import Dumps as DumpsProtocol

def _get_stringizer() -> DumpsProtocol:
    from taew.adapters.python.pprint.for_stringizing_objects import Dumps
    return Dumps()

class TestStringizing(unittest.TestCase):
    def test_stringation_dict(self):
        dumps = _get_stringizer()
        result = dumps({"key": "value"})
        self.assertIn("key", result)
```

This approach ensures adapters are truly interchangeable.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## References

- **Ports & Adapters Pattern**: [Alistair Cockburn's original article](https://alistair.cockburn.us/hexagonal-architecture/)
- **Focus on Core Value and Keep Cloud Infrastructure Flexible**: [Asher Sterkin's article on applying Ports & Adapters in cloud environments](https://medium.com/@asher-sterkin/focus-on-core-value-and-keep-cloud-infrastructure-flexible-with-ports-adapters-af79c5fa1e56)
- **Dependency Inversion Principle**: Part of SOLID principles
- **Protocol-based programming in Python**: [PEP 544](https://peps.python.org/pep-0544/)
